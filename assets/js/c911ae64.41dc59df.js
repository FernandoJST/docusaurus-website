"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[281],{887:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>t,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"paneles/panel-memoria","title":"Panel Memoria: Diagn\xf3stico de Uso de Memoria y Fugas","description":"El panel Memoria (Memory) es la herramienta principal para analizar el uso de memoria de tu aplicaci\xf3n web. Es crucial para identificar cu\xe1ndo la p\xe1gina consume demasiada memoria (lo que puede ralentizarla o hacerla colapsar) y, sobre todo, para detectar fugas de memoria.","source":"@site/docs/paneles/09-panel-memoria.md","sourceDirName":"paneles","slug":"/paneles/panel-memoria","permalink":"/docusaurus-website/docs/paneles/panel-memoria","draft":false,"unlisted":false,"editUrl":"https://github.com/FernandoJST/docusaurus-website/tree/main/docs/paneles/09-panel-memoria.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Panel Rendimiento: Optimizando la Velocidad de Ejecuci\xf3n","permalink":"/docusaurus-website/docs/paneles/panel-rendimiento"},"next":{"title":"Panel Aplicaci\xf3n: Explorando Recursos y Almacenamiento","permalink":"/docusaurus-website/docs/paneles/panel-aplicacion"}}');var o=n(4848),i=n(8453);const r={},l="Panel Memoria: Diagn\xf3stico de Uso de Memoria y Fugas",t={},c=[{value:"\xbfQu\xe9 es una Fuga de Memoria?",id:"qu\xe9-es-una-fuga-de-memoria",level:3},{value:"Tipos de Perfiles de Memoria",id:"tipos-de-perfiles-de-memoria",level:3},{value:"Tomando y Analizando un Heap Snapshot",id:"tomando-y-analizando-un-heap-snapshot",level:3},{value:"Detectando Fugas de Memoria con Comparaci\xf3n",id:"detectando-fugas-de-memoria-con-comparaci\xf3n",level:3},{value:"Causas Comunes de Fugas de Memoria",id:"causas-comunes-de-fugas-de-memoria",level:3}];function d(e){const a={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.header,{children:(0,o.jsx)(a.h1,{id:"panel-memoria-diagn\xf3stico-de-uso-de-memoria-y-fugas",children:"Panel Memoria: Diagn\xf3stico de Uso de Memoria y Fugas"})}),"\n",(0,o.jsxs)(a.p,{children:["El panel ",(0,o.jsx)(a.strong,{children:"Memoria"})," (Memory) es la herramienta principal para ",(0,o.jsx)(a.strong,{children:"analizar el uso de memoria"})," de tu aplicaci\xf3n web. Es crucial para identificar cu\xe1ndo la p\xe1gina consume demasiada memoria (lo que puede ralentizarla o hacerla colapsar) y, sobre todo, para detectar ",(0,o.jsx)(a.strong,{children:"fugas de memoria"}),"."]}),"\n",(0,o.jsx)(a.h3,{id:"qu\xe9-es-una-fuga-de-memoria",children:"\xbfQu\xe9 es una Fuga de Memoria?"}),"\n",(0,o.jsxs)(a.p,{children:['En JavaScript, la gesti\xf3n de memoria la realiza principalmente un recolector de basura (Garbage Collector - GC). El GC identifica objetos que ya no son "alcanzables" desde el c\xf3digo en ejecuci\xf3n y libera la memoria que ocupan. Una fuga de memoria ocurre cuando hay ',(0,o.jsx)(a.strong,{children:"objetos que ya no necesitas, pero siguen siendo referenciados"})," de alguna manera, impidiendo que el GC los libere. Con el tiempo, esto puede llevar a un consumo de memoria creciente y problemas de rendimiento."]}),"\n",(0,o.jsx)(a.h3,{id:"tipos-de-perfiles-de-memoria",children:"Tipos de Perfiles de Memoria"}),"\n",(0,o.jsx)(a.p,{children:"El panel Memoria ofrece diferentes formas de perfilar el uso de memoria:"}),"\n",(0,o.jsxs)(a.ol,{children:["\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Heap Snapshot (Instant\xe1nea del Mont\xedculo):"}),' Esta es la herramienta m\xe1s utilizada para encontrar fugas de memoria. Toma una "fotograf\xeda" del estado de la memoria JavaScript en un momento espec\xedfico. Muestra todos los objetos que est\xe1n en memoria, sus tama\xf1os y las referencias entre ellos.']}),"\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Allocation instrumentation on timeline (Instrumentaci\xf3n de asignaci\xf3n en la l\xednea de tiempo):"})," Graba las asignaciones de memoria a lo largo del tiempo. \xdatil para ver cu\xe1ndo se asigna memoria y qu\xe9 funciones son responsables."]}),"\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Allocation sampling (Muestreo de asignaci\xf3n):"})," Similar al anterior pero menos detallado, con menos sobrecarga de rendimiento. \xdatil para perfiles largos o complejos."]}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:"Nos centraremos en los Heap Snapshots para la detecci\xf3n de fugas."}),"\n",(0,o.jsx)(a.h3,{id:"tomando-y-analizando-un-heap-snapshot",children:"Tomando y Analizando un Heap Snapshot"}),"\n",(0,o.jsxs)(a.ol,{children:["\n",(0,o.jsx)(a.li,{children:"Abre el panel Memoria."}),"\n",(0,o.jsxs)(a.li,{children:["Selecciona ",(0,o.jsx)(a.strong,{children:'"Heap snapshot"'})," en las opciones de perfilado."]}),"\n",(0,o.jsxs)(a.li,{children:["Haz clic en ",(0,o.jsx)(a.strong,{children:'"Take snapshot"'})," (Tomar instant\xe1nea). El navegador pausar\xe1 brevemente para capturar el estado de la memoria. La instant\xe1nea aparecer\xe1 en el panel lateral izquierdo."]}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.img,{alt:"Tomando un Heap Snapshot",src:n(4233).A+"",width:"854",height:"602"})}),"\n",(0,o.jsxs)(a.ol,{start:"4",children:["\n",(0,o.jsxs)(a.li,{children:["Al seleccionar una instant\xe1nea, el \xe1rea principal mostrar\xe1 los objetos en la memoria. La vista por defecto suele estar agrupada por constructor (",(0,o.jsx)(a.code,{children:"Constructor"}),"). Columnas importantes incluyen:","\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Distance:"}),' La distancia m\xe1s corta a la "ra\xedz" del recolector de basura (objetos globales, la pila de llamadas, etc.). Objetos con una distancia peque\xf1a son m\xe1s propensos a ser mantenidos.']}),"\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Shallow Size:"})," El tama\xf1o de la memoria que ocupa el objeto ",(0,o.jsx)(a.em,{children:"en s\xed mismo"}),"."]}),"\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Retained Size:"})," El tama\xf1o total de la memoria que se libera si este objeto fuera eliminado, incluyendo los objetos que solo son referenciados por \xe9l. Este es un indicador clave del impacto de un objeto."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(a.h3,{id:"detectando-fugas-de-memoria-con-comparaci\xf3n",children:"Detectando Fugas de Memoria con Comparaci\xf3n"}),"\n",(0,o.jsx)(a.p,{children:"La t\xe9cnica m\xe1s efectiva para encontrar fugas es comparar snapshots:"}),"\n",(0,o.jsxs)(a.ol,{children:["\n",(0,o.jsx)(a.li,{children:"Realiza una acci\xf3n en tu aplicaci\xf3n (ej. abrir un modal)."}),"\n",(0,o.jsxs)(a.li,{children:["Toma el ",(0,o.jsx)(a.strong,{children:"primer Heap Snapshot"}),"."]}),"\n",(0,o.jsxs)(a.li,{children:["Realiza la acci\xf3n que sospechas que causa la fuga ",(0,o.jsx)(a.strong,{children:"varias veces"})," (ej. abrir y cerrar el modal 3-4 veces). ",(0,o.jsx)(a.strong,{children:"Espera un poco"})," entre interacciones para dar tiempo al GC."]}),"\n",(0,o.jsxs)(a.li,{children:["Realiza una ",(0,o.jsx)(a.strong,{children:"acci\xf3n inversa"})," si aplica (ej. cierra el modal que abriste)."]}),"\n",(0,o.jsxs)(a.li,{children:["Toma el ",(0,o.jsx)(a.strong,{children:"segundo Heap Snapshot"}),"."]}),"\n",(0,o.jsxs)(a.li,{children:["En la vista del ",(0,o.jsx)(a.strong,{children:"segundo"}),' snapshot, cambia el modo de vista en el men\xfa desplegable superior de "Summary" (Resumen) a ',(0,o.jsx)(a.strong,{children:'"Comparison"'})," (Comparaci\xf3n). Selecciona el primer snapshot para comparar."]}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.img,{alt:"Comparando dos Heap Snapshots",src:n(4640).A+"",width:"859",height:"491"})}),"\n",(0,o.jsxs)(a.ol,{start:"7",children:["\n",(0,o.jsxs)(a.li,{children:["La columna ",(0,o.jsx)(a.strong,{children:'"# Delta"'})," te mostrar\xe1 la diferencia en el n\xfamero de objetos entre los dos snapshots. Una fuga se manifiesta a menudo como un ",(0,o.jsx)(a.strong,{children:"aumento constante en el n\xfamero de objetos"})," de un tipo espec\xedfico que esperabas que fueran eliminados (ej. nodos del DOM, instancias de una clase de componente) despu\xe9s de realizar una acci\xf3n repetidamente."]}),"\n",(0,o.jsx)(a.li,{children:'Ordena la tabla por "# Delta" (descendente) o por "Delta (Retained Size)" para ver qu\xe9 objetos est\xe1n aumentando.'}),"\n",(0,o.jsxs)(a.li,{children:["Selecciona un tipo de objeto sospechoso (ej. ",(0,o.jsx)(a.code,{children:"HTMLDivElement"})," si sospechas de nodos DOM filtrados). En el panel inferior, la secci\xf3n ",(0,o.jsx)(a.strong,{children:'"Retainers"'})," (Retenedores) mostrar\xe1 la ",(0,o.jsx)(a.strong,{children:"ruta de retenci\xf3n"}),". Esta es la cadena de referencias de objetos que est\xe1 impidiendo que el objeto seleccionado sea recolectado por el GC."]}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.img,{alt:"Inspeccionando la ruta de retenci\xf3n de un objeto",src:n(1126).A+"",width:"864",height:"531"})}),"\n",(0,o.jsxs)(a.ol,{start:"10",children:["\n",(0,o.jsx)(a.li,{children:'Analiza la ruta de retenci\xf3n para identificar la referencia "culpable" en tu c\xf3digo que est\xe1 manteniendo vivo el objeto innecesariamente.'}),"\n"]}),"\n",(0,o.jsx)(a.h3,{id:"causas-comunes-de-fugas-de-memoria",children:"Causas Comunes de Fugas de Memoria"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:"Referencias no eliminadas en detectores de eventos (event listeners)."}),"\n",(0,o.jsxs)(a.li,{children:["Timers (",(0,o.jsx)(a.code,{children:"setInterval"}),", ",(0,o.jsx)(a.code,{children:"setTimeout"}),") que no se cancelan."]}),"\n",(0,o.jsx)(a.li,{children:"Cierres (Closures) que capturan variables innecesariamente."}),"\n",(0,o.jsx)(a.li,{children:"Cach\xe9s que crecen indefinidamente."}),"\n",(0,o.jsx)(a.li,{children:"Referencias a nodos del DOM que han sido removidos de la p\xe1gina pero no liberados."}),"\n"]}),"\n",(0,o.jsx)(a.p,{children:"El panel Memoria requiere una comprensi\xf3n m\xe1s profunda de c\xf3mo JavaScript gestiona la memoria, pero es una herramienta esencial para aplicaciones de larga ejecuci\xf3n, complejas o propensas a problemas de rendimiento a largo plazo."})]})}function m(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1126:(e,a,n)=>{n.d(a,{A:()=>s});const s=n.p+"assets/images/inspector-memoria-retainers-b124a7b9a6933dd05ed3b07fafc1f855.png"},4233:(e,a,n)=>{n.d(a,{A:()=>s});const s=n.p+"assets/images/inspector-memoria-take-snapshot-4a6f71b8804c2930795e5b0ac0a13d68.png"},4640:(e,a,n)=>{n.d(a,{A:()=>s});const s=n.p+"assets/images/inspector-memoria-comparison-5ecb4024fee4e0e0b9a5ea33fc833ab2.png"},8453:(e,a,n)=>{n.d(a,{R:()=>r,x:()=>l});var s=n(6540);const o={},i=s.createContext(o);function r(e){const a=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:a},e.children)}}}]);